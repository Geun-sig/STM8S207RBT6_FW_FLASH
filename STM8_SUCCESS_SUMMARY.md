# STM8S207RBT6 부트로더 통신 성공 요약

**날짜**: 2026-01-05
**타겟 MCU**: STM8S207RBT6 (128KB Flash)
**결과**: ✅ **EW Routines 다운로드 성공**

---

## 최종 성공 결과

### 성공한 단계

1. ✅ **부트로더 진입** - 애플리케이션 모드에서 부트로더 모드로 전환
2. ✅ **부트로더 초기화** - 0x7F 동기화 바이트 전송 → 0x79 ACK 수신
3. ✅ **부트로더 정보 확인** - STBL_GET 명령으로 버전 2.2 확인
4. ✅ **EW Routines 다운로드** - RAM(0x00A0)에 352바이트 성공적으로 전송

### 확인된 부트로더 정보

```
부트로더 버전: 2.2 (0x22)
지원 명령 수: 5개
지원 명령: GET, READ, GO, WRITE, ERASE
```

---

## 해결한 주요 문제들

### 1️⃣ 주소 형식 오류 (3바이트 → 4바이트)

**문제**:
- 초기 코드는 3바이트 주소를 전송하여 부트로더가 무응답
- 예: `[00 00 A0]` (잘못됨)

**해결**:
- STM8도 STM32와 동일한 4바이트 주소 프로토콜 사용
- 예: `[00 00 00 A0]` (올바름)

**코드 수정**:
```python
# 이전 (잘못됨)
addr_bytes = address.to_bytes(3, 'big')
checksum = addr_bytes[0] ^ addr_bytes[1] ^ addr_bytes[2]

# 수정 (올바름)
addr_bytes = address.to_bytes(4, 'big')
checksum = addr_bytes[0] ^ addr_bytes[1] ^ addr_bytes[2] ^ addr_bytes[3]
```

**영향 받은 함수**:
- `write_memory()` - 메모리 쓰기
- `reset_mcu()` - MCU 리셋 (GO 명령)

---

### 2️⃣ 패킷 크기 오류 (256바이트 → 128바이트)

**문제**:
- 주소 ACK는 받았지만 데이터 전송 후 NACK(0x1F) 발생
- STM32는 256바이트 지원하지만 STM8은 128바이트만 지원

**해결**:
- `STM8_128K.STmap` 확인: `PacketSize=80` (16진수 = 128바이트)
- 청크 크기를 128바이트로 제한

**코드 수정**:
```python
# 이전 (잘못됨)
chunk_size = 256
if len(data) > 256:
    raise Exception("데이터 청크가 너무 큼")

# 수정 (올바름)
chunk_size = 128
if len(data) > 128:
    raise Exception("데이터 청크가 너무 큼 (최대 128바이트)")
```

**영향 받은 함수**:
- `download_ew_routines()` - EW Routines 다운로드
- `program_firmware()` - 펌웨어 다운로드
- `write_memory()` - 최대 크기 검증

---

### 3️⃣ 부트로더 버전 불일치

**문제**:
- 부트로더 버전을 모르면 적절한 EW Routines 파일을 선택할 수 없음

**해결**:
- STBL_GET 명령 구현으로 부트로더 버전 자동 감지
- 버전에 맞는 EW Routines 파일 자동 선택

**구현 기능**:
```python
def get_bootloader_info(self):
    """부트로더 버전 및 지원 명령 목록 확인"""
    # 1. GET 명령 전송: 0x00 0xFF
    # 2. 버전 수신: 0x22 → "2.2"
    # 3. 명령 목록 수신: [0x00, 0x11, 0x21, 0x31, 0x43]
    # 4. 파일 자동 선택: E_W_ROUTINEs_128K_ver_2.2.s19
```

**Fallback 로직**:
- 버전별 파일이 없으면 자동으로 다른 버전 시도
- 우선순위: 2.4 → 2.2 → 2.1 → 2.0

---

## 핵심 발견 사항

### STM8 부트로더 프로토콜 = STM32 프로토콜

STM8과 STM32는 **동일한 부트로더 프로토콜**을 사용합니다:

| 항목 | STM32F103 | STM8S207RBT6 | 비고 |
|------|-----------|--------------|------|
| **주소 형식** | 4바이트 | 4바이트 | ✅ 동일 |
| **명령 코드** | 0x31, 0x43, 0x21 | 0x31, 0x43, 0x21 | ✅ 동일 |
| **ACK/NACK** | 0x79 / 0x1F | 0x79 / 0x1F | ✅ 동일 |
| **패킷 크기** | 256바이트 | 128바이트 | ⚠️ 다름 |
| **부트로더 속도** | 115200 baud | 57600 baud | ⚠️ 다름 |
| **EW Routines** | 불필요 | 필수 | ⚠️ 다름 |

### STM8 특화 요구사항

1. **EW Routines 필수**
   - STM8은 플래시 삭제/쓰기 전에 RAM에 실행 루틴을 다운로드해야 함
   - 주소: 0x00A0 - 0x0200 (352바이트)
   - 버전별 파일 필요 (2.0, 2.1, 2.2, 2.4)

2. **패킷 크기 제한**
   - 최대 128바이트 (0x80)
   - STM32의 절반 크기

3. **통신 속도**
   - 애플리케이션 모드: 9600 baud, No Parity
   - 부트로더 모드: 57600 baud, Even Parity

---

## 구현된 주요 함수

### 1. `get_bootloader_info()` - 부트로더 정보 확인

**프로토콜**:
```
PC → MCU: 0x00 0xFF (GET 명령)
MCU → PC: 0x79 (ACK)
MCU → PC: 0x05 (명령 개수)
MCU → PC: 0x22 (버전: 2.2)
MCU → PC: [0x00, 0x11, 0x21, 0x31, 0x43] (명령 목록)
MCU → PC: 0x79 (최종 ACK)
```

**반환값**:
```python
{
    'version': 0x22,
    'version_str': "2.2",
    'commands': [0x00, 0x11, 0x21, 0x31, 0x43],
    'supported_commands': ["GET", "READ", "GO", "WRITE", "ERASE"],
    'has_write': True,
    'has_erase': True
}
```

### 2. `write_memory(address, data)` - 메모리 쓰기

**프로토콜** (4바이트 주소, 최대 128바이트):
```
PC → MCU: 0x31 0xCE (WRITE 명령)
MCU → PC: 0x79 (ACK)
PC → MCU: [00 00 00 A0] + 체크섬 (4바이트 주소)
MCU → PC: 0x79 (ACK)
PC → MCU: 0x7F (N=127, 128바이트) + 데이터(128) + 체크섬
MCU → PC: 0x79 (ACK)
```

**주요 로직**:
```python
# 4바이트 주소
addr_bytes = address.to_bytes(4, 'big')
checksum = addr_bytes[0] ^ addr_bytes[1] ^ addr_bytes[2] ^ addr_bytes[3]

# 데이터 (최대 128바이트)
length_byte = len(data) - 1  # N = 실제 길이 - 1
chksum = length_byte
for b in data:
    chksum ^= b
```

### 3. `download_ew_routines(bl_info)` - EW Routines 다운로드

**워크플로우**:
```python
1. 부트로더 버전 확인 (bl_info['version_str'])
2. 버전에 맞는 S19 파일 선택 (E_W_ROUTINEs_128K_ver_2.2.s19)
3. S19 파일 로드 (bincopy 라이브러리)
4. 128바이트 청크로 분할
5. 각 청크를 RAM(0x00A0)에 write_memory() 호출
   - 청크 1: 0x00A0 (128바이트)
   - 청크 2: 0x0120 (128바이트)
   - 청크 3: 0x01A0 (96바이트)
6. 다운로드 완료
```

### 4. `reset_mcu()` - MCU 리셋

**프로토콜** (4바이트 주소):
```
PC → MCU: 0x21 0xDE (GO 명령)
MCU → PC: 0x79 (ACK)
PC → MCU: [00 00 80 00] + 체크섬 (주소: 0x008000)
MCU → PC: 0x79 또는 무응답 (리셋되면 응답 없을 수 있음)
```

---

## 전체 워크플로우

```
┌─────────────────────────────────────────────────────┐
│ 1. 부트로더 진입                                     │
│    - 9600 baud, No Parity                           │
│    - 명령: $LICMD,C*20\r\n                          │
│    - 응답: "Process FW Update..."                   │
│    - 57600 baud, Even Parity로 전환                 │
└────────────────┬────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────┐
│ 2. 부트로더 초기화                                   │
│    - 전송: 0x7F                                     │
│    - 수신: 0x79 (ACK)                               │
└────────────────┬────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────┐
│ 3. 부트로더 정보 확인 (STBL_GET) ✅ NEW             │
│    - 명령: 0x00 0xFF                                │
│    - 버전: 2.2                                      │
│    - 명령: GET, READ, GO, WRITE, ERASE              │
└────────────────┬────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────┐
│ 4. EW Routines 다운로드 ✅ 성공                     │
│    - 파일: E_W_ROUTINEs_128K_ver_2.2.s19           │
│    - 주소: 0x00A0 - 0x0200                          │
│    - 크기: 352바이트 (3개 청크 × 128바이트)         │
│    - 프로토콜: WRITE 명령 (4바이트 주소)            │
└────────────────┬────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────┐
│ 5. 플래시 삭제 (다음 단계)                          │
│    - 명령: 0x43 0xBC                                │
│    - 데이터: 0xFF 0x00 (전체 삭제)                  │
│    - 타임아웃: 30초                                  │
└────────────────┬────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────┐
│ 6. 펌웨어 다운로드 (다음 단계)                       │
│    - S19 파일 로드                                  │
│    - 128바이트 청크로 분할                          │
│    - WRITE 명령으로 플래시에 쓰기                   │
└────────────────┬────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────┐
│ 7. MCU 리셋 (다음 단계)                             │
│    - 명령: 0x21 0xDE                                │
│    - 주소: 0x008000 (4바이트)                       │
└─────────────────────────────────────────────────────┘
```

---

## 성공 로그 예시

```
10:48:56 - 부트로더 통신 모드로 전환 중...
10:48:56 - 부트로더 동기화 시도 1/5
10:48:56 - 부트로더 ACK 수신됨
10:48:56 - 부트로더 정보 확인 중...
10:48:56 - 명령 개수: 5개
10:48:56 - 부트로더 버전: 2.2 (0x22)
10:48:56 - 지원 명령: GET, READ, GO, WRITE, ERASE
10:48:56 - ✓ 부트로더 버전: 2.2
10:48:56 - ✓ 지원 명령 수: 5개
10:48:56 - EW Routines 다운로드 중...
10:48:56 - 부트로더 버전 2.2에 맞는 EW Routines 선택
10:48:57 - EW Routines 로드됨: 0x00A0 - 0x0200 (352 바이트)
10:48:57 - EW Routines를 3개 청크로 전송 중...
10:48:57 - 청크 1/3: 0x00A0 (128 바이트)
10:48:57 - 주소 전송: [00 00 00 A0] 체크섬: 0xA0
10:48:57 - 데이터 전송: 128 바이트 (N=127, 체크섬=0x...)
10:48:57 - 청크 2/3: 0x0120 (128 바이트)
10:48:57 - 주소 전송: [00 00 01 20] 체크섬: 0x21
10:48:57 - 데이터 전송: 128 바이트 (N=127, 체크섬=0x...)
10:48:57 - 청크 3/3: 0x01A0 (96 바이트)
10:48:57 - 주소 전송: [00 00 01 A0] 체크섬: 0xA1
10:48:57 - 데이터 전송: 96 바이트 (N=95, 체크섬=0x...)
10:48:57 - EW Routines 다운로드 완료 ✅
```

---

## 파일 구조

```
D:\stm_work\python\
├── flash_stm8_gui.py                    # 메인 프로그램 (약 950 라인)
├── E_W_ROUTINEs_128K_ver_2.2.s19       # EW Routines (버전 2.2)
├── E_W_ROUTINEs_128K_ver_2.4.s19       # EW Routines (버전 2.4)
├── marine_logo.png                      # 마린테크 로고
├── CLAUDE.md                            # 상세 작업 이력
├── stm8boot_process.md                  # Sources 분석 문서
├── STM8_SUCCESS_SUMMARY.md             # 성공 요약 (이 문서)
└── Sources/                             # STM Flash Loader 소스
    ├── STUARTBLLIB/STUARTBLLIB.cpp     # UART 부트로더 프로토콜
    ├── STMFlashLoader/STMFlashLoader.cpp
    └── BIN/Map/STM8_128K.STmap         # STM8 메모리 맵
```

---

## 주요 라이브러리

```python
from PySide6.QtWidgets import *  # GUI 프레임워크
from PySide6.QtCore import QThread, Signal
import serial                     # 시리얼 통신
import bincopy                    # S19 파일 파싱
```

**요구사항**:
- Python 3.7+
- PySide6 (Qt for Python)
- pyserial
- bincopy

---

## 다음 단계

1. ✅ **EW Routines 다운로드 완료**
2. ⏳ **플래시 삭제** (ERASE 명령, 타임아웃 30초)
3. ⏳ **펌웨어 다운로드** (S19 파일, 128바이트 청크)
4. ⏳ **검증** (옵션)
5. ⏳ **MCU 리셋** (GO 명령, 0x008000)

---

## 핵심 교훈

### 1. 프로토콜 문서보다 실제 구현 코드가 정확하다

- STM8 문서에는 3바이트 주소라고 나와있지만
- 실제 Sources 코드는 4바이트 주소를 사용
- **공식 소스 코드(Sources)를 분석한 것이 성공의 핵심**

### 2. 작은 차이가 큰 영향을 미친다

- 주소 길이 1바이트 차이 → 무응답
- 패킷 크기 128바이트 차이 → NACK
- **정확한 프로토콜 준수가 필수**

### 3. 디버깅 로그의 중요성

- 주소/데이터를 HEX로 출력하여 정확히 확인
- 각 단계별 성공/실패를 명확히 로깅
- **문제 해결 속도를 크게 향상**

### 4. 단계별 접근

1. 부트로더 진입 → 성공
2. 초기화 → 성공
3. 버전 확인 → 성공 (새로 추가)
4. EW Routines → 성공 (주소/크기 수정)
5. 다음 단계로 진행

**각 단계를 완전히 검증한 후 다음으로 진행**

---

## 참고 문서

- **UM0560**: STM8 bootloader user manual
- **AN2659**: STM8 bootloader application note
- **Sources/STUARTBLLIB/**: UART 부트로더 프로토콜 구현 (가장 중요!)
- **Sources/BIN/Map/STM8_128K.STmap**: STM8 설정 파일

---

**작성일**: 2026-01-05
**작성자**: Claude (Sonnet 4.5)
**상태**: ✅ EW Routines 다운로드 성공, 플래시 삭제 준비 완료
